#include <bits/stdc++.h>
class TrieNode {
public:
    char ch;
    TrieNode* children[26];
    bool isTerminal;

    TrieNode(char ch) {
        this->ch = ch;
        for (int i = 0; i < 26; i++) {
            children[i] = NULL;
        }
        isTerminal = false;
    }
};

class Trie {
public:
    TrieNode* root;

    Trie() { root = new TrieNode('\0'); }

    void insertUtil(TrieNode* node, string& word, int index) {
        // base case: whole word processed
        if (index == word.size()) {
            node->isTerminal = true;
            return;
        }

        int childIndex = word[index] - 'a'; // assumes uppercase input
        TrieNode* child;

        if (node->children[childIndex] != NULL) {
            child = node->children[childIndex];
        } else {
            child = new TrieNode(word[index]);
            node->children[childIndex] = child;
        }

        insertUtil(child, word, index + 1);
    }

    void insertWord(string word) { insertUtil(root, word, 0); }

    string getNewSentence(string word) {

        TrieNode* node = root;
        string prefix = "";
        for (char c : word) {
            int index = c - 'a';
            if (node->children[index] == NULL) {
                // no match, return original word
                return word;
            }
            prefix.push_back(c);
            node = node->children[index];
            if (node->isTerminal) {

                return prefix;
            }
        }
        return word;
    }
};

class Solution {
public:
    string replaceWords(vector<string>& dictionary, string sentence) {

        Trie* t = new Trie();

        for (int i = 0; i < dictionary.size(); i++) {
            t->insertWord(dictionary[i]);
        }

        stringstream ss(sentence);
        vector<string> words;

        string word;

        while (ss >> word) {
            words.push_back(word);
        }
        string res = "";

        for (int i = 0; i < words.size(); i++) {

            string ans = t->getNewSentence(words[i]);
            res = res + ans + " ";
        }
        if (!res.empty() && res.back() == ' ') {
            res.pop_back();
        }
        return res;
    }
};
